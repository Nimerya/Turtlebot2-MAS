:- use_module(library(file_systems)).
:- use_module(library(system)).

:- compile('../mas/redis_client.pl').
:- compile('../mas/stringESE.pl').

:- dynamic vision/2. 
:- dynamic depth/1. 
:- dynamic load/1. 
:- dynamic agentname/1.

/* received message must be of the form 'predicate. predicate. ...'
   external event triggered by the arrival of a message */
redisE(X) :> print('Received message: '),
             pulisciStringa(X,Y), 
             print(Y), nl, 
             addKnowledge(Y).

/* add information to the kb by creating a new .pl file and compiling it */
addKnowledge(S) :- open('addedKnowledge.pl', write, W),
                   write(W, S),
                   close(W),
                   compile('addedKnowledge.pl').

/* incapsulate the answer procedure (send and kb cleaning) */
answer(X) :- agentname(N),
             atom_concat(N,X,Res),
             mas_send(Res),
             print('action: '),
             print(X),
             nl,
             retractall(vision(_,_)),
             retractall(depth(_)),
             retractall(load(_)).

/* obstacle avoidance: if the unit has somthing near that is not the target */
avoid :- depth(near), \+ vision(_,near).
avoidI :> answer('right:40').

/* stop: if the unit is near the green conveyor belt and it is full */
unload :- vision(green, near), load(full).
unloadI :> answer('unload').

/* stop: if the unit is near the red conveyor belt and it is empty */
loadup :- vision(red, near), load(empty).
loadupI :> answer('loadup').

/* follow: if the unit sees the conveyor belt to one of its sides */
follow(X) :- vision(_,X), \+ vision(_,center), \+ vision(_,none), depth(far).
followI(X) :> atom_concat(X, ':5', Res), answer(Res).

/* forward: if the unit sees the convayor belt in front of it */
forward :- vision(green,center), depth(far), load(full).
forward :- vision(red,center), depth(far), load(empty).
forwardI :> answer('go:2').

/* if the unit is facing the wrong direction */
turn :- vision(green,center), load(empty). 
turn :- vision(red,center), load(full).
turn :- vision(green,near), load(empty).
turn :- vision(red,near), load(full).
turnI :> answer('right:150').

/* if the unit do not see a target */
wanderAround :- vision(none,none).
wanderAroundI :> answer('right:30').
